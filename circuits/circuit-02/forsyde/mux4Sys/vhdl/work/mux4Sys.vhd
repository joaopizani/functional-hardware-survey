-- Automatically generated by ForSyDe
library forsyde;
library ieee;
use forsyde.types.all;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library mux4Sys_lib;
use mux4Sys_lib.types.all;


entity \mux4Sys\ is
     port (\sel\ : in fsvec_2_std_logic;
           \inputs\ : in fsvec_4_int16;
           \out\ : out int16);
end entity \mux4Sys\;


architecture synthesizable of \mux4Sys\ is
     signal \muxA:unzipSel_out1\ : std_logic;
     signal \muxA:unzipSel_out2\ : std_logic;
     signal \muxA:unzipInp_out1\ : int16;
     signal \muxA:unzipInp_out2\ : int16;
     signal \muxA:unzipInp_out3\ : int16;
     signal \muxA:unzipInp_out4\ : int16;
     signal \muxA:m00_out\ : int16;
     signal \muxA:m01_out\ : int16;
     signal \muxA:m1_out\ : int16;
begin
     \muxA:unzipSel\ : block
          port (\muxA:unzipSel_in\ : in fsvec_2_std_logic;
                \muxA:unzipSel_out1\ : out std_logic;
                \muxA:unzipSel_out2\ : out std_logic);
          port map (\muxA:unzipSel_in\ => \sel\,
                    \muxA:unzipSel_out1\ => \muxA:unzipSel_out1\,
                    \muxA:unzipSel_out2\ => \muxA:unzipSel_out2\);
     begin
          \muxA:unzipSel_out1\ <= \muxA:unzipSel_in\(0);
          \muxA:unzipSel_out2\ <= \muxA:unzipSel_in\(1);
     end block \muxA:unzipSel\;
     
     \muxA:unzipInp\ : block
          port (\muxA:unzipInp_in\ : in fsvec_4_int16;
                \muxA:unzipInp_out1\ : out int16;
                \muxA:unzipInp_out2\ : out int16;
                \muxA:unzipInp_out3\ : out int16;
                \muxA:unzipInp_out4\ : out int16);
          port map (\muxA:unzipInp_in\ => \inputs\,
                    \muxA:unzipInp_out1\ => \muxA:unzipInp_out1\,
                    \muxA:unzipInp_out2\ => \muxA:unzipInp_out2\,
                    \muxA:unzipInp_out3\ => \muxA:unzipInp_out3\,
                    \muxA:unzipInp_out4\ => \muxA:unzipInp_out4\);
     begin
          \muxA:unzipInp_out1\ <= \muxA:unzipInp_in\(0);
          \muxA:unzipInp_out2\ <= \muxA:unzipInp_in\(1);
          \muxA:unzipInp_out3\ <= \muxA:unzipInp_in\(2);
          \muxA:unzipInp_out4\ <= \muxA:unzipInp_in\(3);
     end block \muxA:unzipInp\;
     
     \muxA:m00\ : block
          port (\muxA:m00_in1\ : in std_logic;
                \muxA:m00_in2\ : in int16;
                \muxA:m00_in3\ : in int16;
                \muxA:m00_out\ : out int16);
          port map (\muxA:m00_in1\ => \muxA:unzipSel_out1\,
                    \muxA:m00_in2\ => \muxA:unzipInp_out1\,
                    \muxA:m00_in3\ => \muxA:unzipInp_out2\,
                    \muxA:m00_out\ => \muxA:m00_out\);
          function \f\ (\s_0\ : std_logic;
                        \x_0\ : int16;
                        \y_0\ : int16)
                       return int16 is
          begin
               if \s_0\ = '0' then
                    return \x_0\;
               else
                    return \y_0\;
               end if;
          end;
     begin
          \muxA:m00_out\ <= \f\(\s_0\ => \muxA:unzipSel_out1\,
                                \x_0\ => \muxA:unzipInp_out1\,
                                \y_0\ => \muxA:unzipInp_out2\);
     end block \muxA:m00\;
     
     \muxA:m01\ : block
          port (\muxA:m01_in1\ : in std_logic;
                \muxA:m01_in2\ : in int16;
                \muxA:m01_in3\ : in int16;
                \muxA:m01_out\ : out int16);
          port map (\muxA:m01_in1\ => \muxA:unzipSel_out1\,
                    \muxA:m01_in2\ => \muxA:unzipInp_out3\,
                    \muxA:m01_in3\ => \muxA:unzipInp_out4\,
                    \muxA:m01_out\ => \muxA:m01_out\);
          function \f\ (\s_0\ : std_logic;
                        \x_0\ : int16;
                        \y_0\ : int16)
                       return int16 is
          begin
               if \s_0\ = '0' then
                    return \x_0\;
               else
                    return \y_0\;
               end if;
          end;
     begin
          \muxA:m01_out\ <= \f\(\s_0\ => \muxA:unzipSel_out1\,
                                \x_0\ => \muxA:unzipInp_out3\,
                                \y_0\ => \muxA:unzipInp_out4\);
     end block \muxA:m01\;
     
     \muxA:m1\ : block
          port (\muxA:m1_in1\ : in std_logic;
                \muxA:m1_in2\ : in int16;
                \muxA:m1_in3\ : in int16;
                \muxA:m1_out\ : out int16);
          port map (\muxA:m1_in1\ => \muxA:unzipSel_out2\,
                    \muxA:m1_in2\ => \muxA:m00_out\,
                    \muxA:m1_in3\ => \muxA:m01_out\,
                    \muxA:m1_out\ => \muxA:m1_out\);
          function \f\ (\s_0\ : std_logic;
                        \x_0\ : int16;
                        \y_0\ : int16)
                       return int16 is
          begin
               if \s_0\ = '0' then
                    return \x_0\;
               else
                    return \y_0\;
               end if;
          end;
     begin
          \muxA:m1_out\ <= \f\(\s_0\ => \muxA:unzipSel_out2\,
                               \x_0\ => \muxA:m00_out\,
                               \y_0\ => \muxA:m01_out\);
     end block \muxA:m1\;
     
     \out\ <= \muxA:m1_out\;
end architecture synthesizable;
