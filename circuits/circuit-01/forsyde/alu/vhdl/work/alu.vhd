-- Automatically generated by ForSyDe
library forsyde;
library ieee;
use forsyde.types.all;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library alu_lib;
use alu_lib.types.all;


entity \alu\ is
     port (\ctrl\ : in tup_6_std_logic_std_logic_std_logic_std_logic_std_logic_std_logic;
           \x\ : in int16;
           \y\ : in int16;
           \outs\ : out tup_2_int16_tup_2_std_logic_std_logic);
end entity \alu\;


architecture synthesizable of \alu\ is
     signal \ctrlProc_out1\ : std_logic;
     signal \ctrlProc_out2\ : std_logic;
     signal \ctrlProc_out3\ : std_logic;
     signal \ctrlProc_out4\ : std_logic;
     signal \ctrlProc_out5\ : std_logic;
     signal \ctrlProc_out6\ : std_logic;
     signal \zx_out\ : int16;
     signal \nx_out\ : int16;
     signal \zy_out\ : int16;
     signal \ny_out\ : int16;
     signal \compProc_out\ : int16;
     signal \no_out\ : int16;
     signal \tzProc_out\ : std_logic;
     signal \tnProc_out\ : std_logic;
     signal \flagsProc_out\ : tup_2_std_logic_std_logic;
     signal \aluProc_out\ : tup_2_int16_tup_2_std_logic_std_logic;
begin
     \ctrlProc\ : block
          port (\ctrlProc_in\ : in tup_6_std_logic_std_logic_std_logic_std_logic_std_logic_std_logic;
                \ctrlProc_out1\ : out std_logic;
                \ctrlProc_out2\ : out std_logic;
                \ctrlProc_out3\ : out std_logic;
                \ctrlProc_out4\ : out std_logic;
                \ctrlProc_out5\ : out std_logic;
                \ctrlProc_out6\ : out std_logic);
          port map (\ctrlProc_in\ => \ctrl\,
                    \ctrlProc_out1\ => \ctrlProc_out1\,
                    \ctrlProc_out2\ => \ctrlProc_out2\,
                    \ctrlProc_out3\ => \ctrlProc_out3\,
                    \ctrlProc_out4\ => \ctrlProc_out4\,
                    \ctrlProc_out5\ => \ctrlProc_out5\,
                    \ctrlProc_out6\ => \ctrlProc_out6\);
     begin
          \ctrlProc_out1\ <= \ctrlProc_in\.tup_1;
          \ctrlProc_out2\ <= \ctrlProc_in\.tup_2;
          \ctrlProc_out3\ <= \ctrlProc_in\.tup_3;
          \ctrlProc_out4\ <= \ctrlProc_in\.tup_4;
          \ctrlProc_out5\ <= \ctrlProc_in\.tup_5;
          \ctrlProc_out6\ <= \ctrlProc_in\.tup_6;
     end block \ctrlProc\;
     
     \zx\ : block
          port (\zx_in1\ : in std_logic;
                \zx_in2\ : in int16;
                \zx_out\ : out int16);
          port map (\zx_in1\ => \ctrlProc_out1\,
                    \zx_in2\ => \x\,
                    \zx_out\ => \zx_out\);
          function \f\ (\z_0\ : std_logic;
                        \w_0\ : int16)
                       return int16 is
          begin
               if \z_0\ = '1' then
                    return 0;
               else
                    return \w_0\;
               end if;
          end;
     begin
          \zx_out\ <= \f\(\z_0\ => \ctrlProc_out1\, \w_0\ => \x\);
     end block \zx\;
     
     \nx\ : block
          port (\nx_in1\ : in std_logic;
                \nx_in2\ : in int16;
                \nx_out\ : out int16);
          port map (\nx_in1\ => \ctrlProc_out2\,
                    \nx_in2\ => \zx_out\,
                    \nx_out\ => \nx_out\);
          function \f\ (\n_0\ : std_logic;
                        \w_0\ : int16)
                       return int16 is
          begin
               if \n_0\ = '1' then
                    return 42;
               else
                    return \w_0\;
               end if;
          end;
     begin
          \nx_out\ <= \f\(\n_0\ => \ctrlProc_out2\, \w_0\ => \zx_out\);
     end block \nx\;
     
     \zy\ : block
          port (\zy_in1\ : in std_logic;
                \zy_in2\ : in int16;
                \zy_out\ : out int16);
          port map (\zy_in1\ => \ctrlProc_out3\,
                    \zy_in2\ => \y\,
                    \zy_out\ => \zy_out\);
          function \f\ (\z_0\ : std_logic;
                        \w_0\ : int16)
                       return int16 is
          begin
               if \z_0\ = '1' then
                    return 0;
               else
                    return \w_0\;
               end if;
          end;
     begin
          \zy_out\ <= \f\(\z_0\ => \ctrlProc_out3\, \w_0\ => \y\);
     end block \zy\;
     
     \ny\ : block
          port (\ny_in1\ : in std_logic;
                \ny_in2\ : in int16;
                \ny_out\ : out int16);
          port map (\ny_in1\ => \ctrlProc_out4\,
                    \ny_in2\ => \zy_out\,
                    \ny_out\ => \ny_out\);
          function \f\ (\n_0\ : std_logic;
                        \w_0\ : int16)
                       return int16 is
          begin
               if \n_0\ = '1' then
                    return 42;
               else
                    return \w_0\;
               end if;
          end;
     begin
          \ny_out\ <= \f\(\n_0\ => \ctrlProc_out4\, \w_0\ => \zy_out\);
     end block \ny\;
     
     \compProc\ : block
          port (\compProc_in1\ : in std_logic;
                \compProc_in2\ : in int16;
                \compProc_in3\ : in int16;
                \compProc_out\ : out int16);
          port map (\compProc_in1\ => \ctrlProc_out5\,
                    \compProc_in2\ => \nx_out\,
                    \compProc_in3\ => \ny_out\,
                    \compProc_out\ => \compProc_out\);
          function \f\ (\o_0\ : std_logic;
                        \x_0\ : int16;
                        \y_0\ : int16)
                       return int16 is
          begin
               if \o_0\ = '1' then
                    return \x_0\ and \y_0\;
               else
                    return \x_0\ + \y_0\;
               end if;
          end;
     begin
          \compProc_out\ <= \f\(\o_0\ => \ctrlProc_out5\,
                                \x_0\ => \nx_out\,
                                \y_0\ => \ny_out\);
     end block \compProc\;
     
     \no\ : block
          port (\no_in1\ : in std_logic;
                \no_in2\ : in int16;
                \no_out\ : out int16);
          port map (\no_in1\ => \ctrlProc_out6\,
                    \no_in2\ => \compProc_out\,
                    \no_out\ => \no_out\);
          function \f\ (\n_0\ : std_logic;
                        \w_0\ : int16)
                       return int16 is
          begin
               if \n_0\ = '1' then
                    return 42;
               else
                    return \w_0\;
               end if;
          end;
     begin
          \no_out\ <= \f\(\n_0\ => \ctrlProc_out6\, \w_0\ => \compProc_out\);
     end block \no\;
     
     \tzProc\ : block
          port (\tzProc_in1\ : in int16;
                \tzProc_out\ : out std_logic);
          port map (\tzProc_in1\ => \no_out\,
                    \tzProc_out\ => \tzProc_out\);
          function \f\ (\w_0\ : int16)
                       return std_logic is
          begin
               if \w_0\ = 0 then
                    return '1';
               else
                    return '0';
               end if;
          end;
     begin
          \tzProc_out\ <= \f\(\w_0\ => \no_out\);
     end block \tzProc\;
     
     \tnProc\ : block
          port (\tnProc_in1\ : in int16;
                \tnProc_out\ : out std_logic);
          port map (\tnProc_in1\ => \no_out\,
                    \tnProc_out\ => \tnProc_out\);
          function \f\ (\w_0\ : int16)
                       return std_logic is
          begin
               if \w_0\ < 0 then
                    return '1';
               else
                    return '0';
               end if;
          end;
     begin
          \tnProc_out\ <= \f\(\w_0\ => \no_out\);
     end block \tnProc\;
     
     \flagsProc\ : block
          port (\flagsProc_in1\ : in std_logic;
                \flagsProc_in2\ : in std_logic;
                \flagsProc_out\ : out tup_2_std_logic_std_logic);
          port map (\flagsProc_in1\ => \tzProc_out\,
                    \flagsProc_in2\ => \tnProc_out\,
                    \flagsProc_out\ => \flagsProc_out\);
          function \tup2\ (\a_0\ : std_logic;
                           \b_0\ : std_logic)
                          return tup_2_std_logic_std_logic is
          begin
               return (\a_0\, \b_0\);
          end;
     begin
          \flagsProc_out\ <= \tup2\(\a_0\ => \tzProc_out\,
                                    \b_0\ => \tnProc_out\);
     end block \flagsProc\;
     
     \aluProc\ : block
          port (\aluProc_in1\ : in int16;
                \aluProc_in2\ : in tup_2_std_logic_std_logic;
                \aluProc_out\ : out tup_2_int16_tup_2_std_logic_std_logic);
          port map (\aluProc_in1\ => \no_out\,
                    \aluProc_in2\ => \flagsProc_out\,
                    \aluProc_out\ => \aluProc_out\);
          function \tup2\ (\a_0\ : int16;
                           \b_0\ : tup_2_std_logic_std_logic)
                          return tup_2_int16_tup_2_std_logic_std_logic is
          begin
               return (\a_0\, \b_0\);
          end;
     begin
          \aluProc_out\ <= \tup2\(\a_0\ => \no_out\, \b_0\ => \flagsProc_out\);
     end block \aluProc\;
     
     \outs\ <= \aluProc_out\;
end architecture synthesizable;
