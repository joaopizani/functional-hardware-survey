\documentclass[a4paper]{article}

%% Unicode support
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{autofe}

\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{a4}
\usepackage{epstopdf}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{color}


%% Code
\usepackage{inconsolata}
\usepackage{minted}
\usepackage{fancyvrb}
\usemintedstyle{default}
\newminted{haskell}{gobble=4,linenos,mathescape,fontfamily=tt,fontsize=\footnotesize,xleftmargin=\parindent}



%% Metainformation
%% PDF stuff
\usepackage{datetime}
\usepackage{ifpdf}
\ifpdf
\pdfinfo{
    /Author (Joao Paulo Pizani Flor)
    /Title (A comparison of functional Embedded Domain-Specific Languages for hardware)
    /Keywords (EDSL, HDL, Hardware Description, Functional Programming, Haskell, Coq, Lava, Coquet)
    /CreationDate (D:\pdfdate)
}
\fi

\title{A comparison of functional Embedded Domain-Specific Languages for hardware}

\date{\today}

\author
{
    Jo√£o Paulo Pizani Flor \\
    Department of Information and Computing Sciences, \\
    Utrecht University - The Netherlands \\
    e-mail: j.p.pizaniflor@students.uu.nl
}



%% The document itself
\begin{document}
    \maketitle

    \section{Introduction}
    \label{sec:intro}
        Hardware design has become nowadays an activity which is, to say the least, extremely
        complex, if not error-prone. The sheer size of circuits has increased. Also, low-level
        concerns such as power consumption, error correction, parallelization and layout
        in general have to be incorporated earlier and earlier in the design process, breaking
        modularity and making it harder to validate and verify the correctness of circuits.

        In this context, researchers have been suggesting for a long time (since the 1980s, in
        fact) the usage of functional programming languages to model circuits. One particular line
        of research is to create Embedded Domain-Specific Languages for hardware description based
        on existing functional programming languages, such as Haskell.

        There is a multitude of EDSLs for hardware description out there, but they vary wildly and
        on a number of aspects: host language, level of abstraction, capabilities of simulation,
        formal verification, synthesis (generation of netlists) and integration with other tools, to
        name a few. All this variety can make the task of choosing a hardware EDSL for the task at
        hand extremely daunting and time-consuming.

        The goal of this experimentation project is to establish some order in this landscape, and
        to perform a practical analysis of some representative functional hardware EDSLs. By reading
        the materials produced in this project (circuit models, test cases, generated netlists,
        report), a hardware designer wishing to use a functional hardware EDSL for his next design
        should gain some insight about the strengths and weaknesses of each language and have an
        easier time choosing one.

    \section{Methodology}
    \label{sec:methods}
        In this project, we compared a number of functional hardware EDSLs that we considered
        representative (more details on the choice of EDSLs further ahead). The comparison was
        performed on a number of \emph{aspects} for each EDSL, and the analysis was done by
        considering a \emph{sample set of circuits} used as case studies.

        We tried to model all circuits in all EDSLs considered, and as similarly as possible in
        all of them. To avoid using any of the analyzed EDSLs as ``base'', we had the circuits
        specified in a neutral hardware description language.

        \subsection{The languages}
        \label{subsec:languages}
            The embedded Hardware Description Languages we decided to analyze are:
            \begin{description}
                \item[Lava] The Lava\cite{lava1998} language, developed initially at Chalmers
                    University in Sweden.  Lava is deeply embedded in Haskell, and provides features
                    such as netlist generation and circuit verification using SAT-solvers. There are
                    several ``dialects'' of Lava available, and the one used for this project is
                    considered the ``canonical'' one, originally developed at Chalmers.

                \item[ForSyDe] The Haskell ForSyDe library is an EDSL based on the ``Formal System
                    Design'' approach\cite{forsyde1999}, developed at the swedish Royal Institute of
                    Technology (KTH).  It offers both shallow and deep embeddings, and uses a
                    significantly different approach to circuit modelling, using \emph{Template
                        Haskell} to allow the designer to describe circuit with ``plain'' Haskell
                    syntax.

                \item[Coquet] The Coquet\cite{coquet2011} EDSL differs from the other 2 mainly
                    because it's embedded in a dependently-typed programming language (the Coq theorem
                    prover). Coquet aims to allow the hardware designer to describe his circuits and
                    then \emph{interactively} prove theorems about the behaviour of whole
                    \emph{families} of circuits (using proofs by induction).
            \end{description}

            The Lava EDSL has several ``dialects'', among which are Xilinx-Lava, York-Lava,
            Kansas-Lava and Chalmers-Lava. Xilinx-Lava was developed by Satnam Singh and has a greater emphasis on the
            \emph{layout} of the described circuits, focusing on their implementation in Xilinx's
            FPGAs. York-Lava was developed as part of the Reduceron project, and is a variation of
            Chalmers-Lava, omitting some features and adding some others, like a ``Prelude'' of
            commonly used circuits ((de)multiplexers, (de)coders, etc.), RAM memory blocks, among
            others.

            %% Kansas-Lava, Chalmers-Lava


        \subsection{The circuits to be modeled}
        \label{subsec:circuits}

        \subsection{The aspects evaluated}
        \label{subsec:aspects}


    \bibliographystyle{plain}
    \bibliography{references}

%% Research question
%% =================
%% A further question to be investigated in this project is what recent developments in
%% Haskell (compiler extensions, etc.), as well as dependently-typed programming, could be used to
%% enhance the EHDLs studied.
%% 
%% Research methods to be employed
%% ===============================
%% First of all, a brief review was done of secondary literature to decide which languages/libraries
%% to investigate. My own experience and background also helped with this choice. The chosen EHDLs
%% are hosted in the purely functional language Haskell and in the dependently-typed Coq. They are:
%% 
%%   * Lava (Chalmers and Kansas varieties) - Embedded in Haskell
%%   * ForSyDe - Embedded in Haskell
%%   * Coquet - Embedded in Coq
%% 
%% Using some mildly-complex circuits as case studies, the EHDLs will be compared based on a number of
%% criteria. The circuits to be described and analyzed in each EHDL will fall under the following
%% classification:
%% 
%%   * **Combinational / arithmetic:** Simple combinational circuit, a mildly-powerful ALU
%%   * **Mostly sequential / state-machine:** Some simple memory component or state machine
%%   * **Mix of combinational / sequential:** A very reduced instruction set processor
%% 
%% Initial research in the literature that defines the EHDLs gave me some ideas of interesting
%% criteria with which to evaluate them. This list might be reduced if it turns out to be too big:
%% 
%%   * Capability/ease of simulation
%%   * Capability/ease of verification (of formal properties)
%%   * Capability to express generic (parameterized) families of circuits
%%     - Parameterized by functional as well as non-functional parameters
%%   * Integration with other tools (implementation)
%%     - Synthesis, theorem provers, etc.
%%   * Level of embedding
%%   * Extensibility
%%     - Multiple interpretations for circuits
%%     - User-defined datatypes
%% 
%% Expected outputs of this project
%% ================================
%% The main output I expect from this project is a comparative analysis of the EHDLs. An interesting
%% side-product will be the code describing the case study circuits in the various languages. This
%% code shall hopefully be useful as a learning source for people interested in experimenting with
%% functional hardware design.
%% 
%% Last, but not least, one output of this project which I also find interesting is the set of
%% comparison criteria itself, along with the justification of why they were chosen.



\end{document}
