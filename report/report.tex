\documentclass[a4paper]{article}

\usepackage{times}
\usepackage[T1]{fontenc}
\usepackage{a4}
\usepackage{epstopdf}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{amssymb}  % lots of math symbols
\usepackage{hyperref}
\usepackage{color}
\usepackage{booktabs}  % nice tables

%% Unicode support
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{autofe}

%% Code
\usepackage{inconsolata}
\usepackage{minted}
\usepackage{fancyvrb}
\usemintedstyle{default}
\newminted{haskell}{gobble=4,linenos,mathescape,fontfamily=tt,xleftmargin=\parindent}




%% Metainformation
%% PDF stuff
\usepackage{datetime}
\usepackage{ifpdf}
\ifpdf
\pdfinfo{
    /Author (Joao Paulo Pizani Flor)
    /Title (Comparing functional Embedded Domain-Specific Languages for hardware description)
    /Keywords (EDSL, HDL, Hardware Description, Functional Programming, Haskell, Coq, Lava, Coquet)
    /CreationDate (D:\pdfdate)
}
\fi

\title{Comparing functional Embedded Domain-Specific Languages for hardware description}

\date{\today}

\author
{
    João Paulo Pizani Flor \\
    Department of Information and Computing Sciences, \\
    Utrecht University - The Netherlands \\
    e-mail: j.p.pizaniflor@students.uu.nl
}



%% The document itself
\begin{document}

    \maketitle

    \section{Introduction}
    \label{sec:intro}
        Hardware design has become a very complex activity. The size of circuits has increased,
        while low-level concerns (power consumption, error correction, parallelization, layout,
        etc.) have to be incorporated earlier and earlier in the design process. This breaks
        modularity and makes it harder to validate and verify the correctness of circuits.

        In this context, researchers have been suggesting (since the 1980s) the usage of functional
        programming languages to model circuits. One particular line of research is to create
        Embedded Domain-Specific Languages for hardware description based on existing functional
        programming languages, such as Haskell.

        There are a multitude of EDSLs for hardware description, but they vary wildly
        on a number of aspects: host language, level of abstraction, capabilities of simulation,
        formal verification, synthesis (generation of netlists) and integration with other tools, to
        name a few. All this variety can make the task of choosing a hardware EDSL for the task at
        hand daunting and time-consuming.

        The main goal of this experimentation project is to establish some order in this landscape,
        and to perform a practical analysis of some popular functional hardware EDSLs. By
        reading the materials produced in this project (circuit models, test cases, generated
        netlists, report), a hardware designer wishing to use a functional hardware EDSL for his
        next design should gain some insight about the strengths and weaknesses of each language and
        have an easier time choosing one.

        As an additional result of this research, we intend to identify recent, cutting-edge
        developments in the Haskell language and its implementations from which the analyzed EDSLs
        could benefit. Also, we intend to discuss to which extent some shortcomings of the EDSLs
        could be overcome by having them hosted in a dependently-typed language.

    \section{Methodology}
    \label{sec:methods}
        In this project, we compared a number of functional hardware EDSLs that we considered
        representative (more details on the choice of EDSLs further ahead). The comparison was
        performed on a number of \emph{aspects} for each EDSL, and the analysis was done by
        considering a \emph{sample set of circuits} used as case studies.

        We tried to model all circuits in all EDSLs considered, and as similarly as possible in each
        EDSL. To avoid using any of the analyzed EDSLs as ``base'' for analysis, we provide a
        neutral, behavioural description of the circuits.

        \subsection{The languages}
        \label{subsec:languages}
            The embedded Hardware Description Languages we decided to analyze are:
            \begin{description}
                \item[Lava] The Lava\cite{lava1998} language, developed initially at Chalmers
                    University in Sweden.  Lava is deeply embedded in Haskell, and provides features
                    such as netlist generation and circuit verification using SAT-solvers. There are
                    several ``dialects'' of Lava available, and the one used for this project is
                    considered the ``canonical'' one, originally developed at Chalmers.

                \item[ForSyDe] The Haskell ForSyDe library is an EDSL based on the ``Formal System
                    Design'' approach\cite{forsyde1999}, developed at the swedish Royal Institute of
                    Technology (KTH).  It offers both shallow and deep embeddings, and provides a
                    significantly different approach to circuit modelling, using \emph{Template
                        Haskell} to allow the designer to describe combinational functions with
                    Haskell's own constructs.

                \item[Coquet] The Coquet\cite{coquet2011} EDSL differs from the other 2 mainly
                    because it's embedded in a dependently-typed programming language (the Coq theorem
                    prover). Coquet aims to allow the hardware designer to describe his circuits and
                    then \emph{interactively} prove theorems about the behaviour of whole
                    \emph{families} of circuits (using proofs by induction).
            \end{description}


        \subsection{The aspects evaluated}
        \label{subsec:aspects}
            For each of the hardware description EDSLs we experimented with, a number of
            \emph{aspects} were evaluated. The evaluated aspects do not necessarily make sense for
            \emph{all} EDSLs, therefore our presentation follows a language-centric approach, in
            which we expose the strengths and weaknesses of each EDSL concerning the applicable
            aspects.

            Without further ado, the following aspects are considered in the analysis:

            \begin{description}
                \item[Simulation]
                    The capability of simulating circuits modeled in the EDSL (and the ease with
                    which it can be performed). Simulation is understood in this context as
                    \emph{functional} simulation, i.e, obtaining the outputs calculated by the
                    circuit for certain input combinations.

                \item[Verification]
                    The capability of verifying \emph{formal properties} concerning the behaviour of
                    circuits (and the ease with which verification can be performed). The properties
                    we are interested in are those which are \emph{universally quantified} over the
                    circuit's inputs. As an example of such a property, we might have:
                    \[
                        \forall a \forall b \forall \text{\textit{sel}}
                            \left( \text{MUX}(a,b,\text{\textit{sel}}) = a \right)
                            \vee
                            \left( \text{MUX}(a,b,\text{\textit{sel}}) = b \right)
                    \]

                \item[Genericity]
                    Whether (and how well) the EDSL allows the modelling of \emph{generic} or
                    \emph{parameterized} circuits. An example of a generic circuit is a multiplexer
                    with 2 n-bit inputs and 1 n-bit output, or a multiplexer with n 1-bit inputs and
                    1 1-bit output. Besides parametrization in the \emph{size} if inputs and
                    outputs, we will also analyze whether the EDSL provides chances for
                    parametrization on other functional and/or non-functional attributes.

                \item[Depth of embedding]
                    Whether the EDSL models circuits with a \emph{shallow} embedding (using
                    predicates or functions of the host language), a \emph{deep embedding}
                    (in which circuits are members of a dedicated data type), or anything in
                    between. The depth of embedding of an EDSL might have consequences for other
                    aspects being analyzed.

                \item[Integration with other tools]
                    How well does the EDSL allow for interaction with (getting input from / generating
                    output for) other tools in the hardware design process. For example, synthesis
                    tools for FPGAs or ASICs, timing analysis tools, model checkers, etc.

                \item[Extensibility]
                    The extent to which the user can \emph{add} new interpretations, data types, and
                    combinator forms to the language. For example, the user might want to model
                    circuits that consume and produce custom datatypes, or might be interested in
                    extracting \emph{metrics} from a circuit such as power consumption, number of
                    elementary gates, etc.
            \end{description}


    \section{Modeled circuits}
    \label{sec:circuits}
        When thinking of which circuits to model using the analyzed EDSLs, some principles guided
        us. First of all, they shouldn't be too simple but also not too complex. Some very simple
        circuits (adders, counters, etc.) are very often shown as examples in the papers that define
        the EDSLs themselves, as well as in tutorials. On the other hand, we also did not want to
        model too complex circuits; that would require too much effort on the hardware design
        itself, and diverge from the focus of this project, which is to evaluate and analyze the
        EDSLs.

        Another principle that guided our choice is that the circuits should be immediately familiar
        to anyone with some minimal experience in hardware design. We avoided, therefore,
        considering application-specific circuits such as those for Digital Signal Processing (DSP),
        implementing communication protocols, etc. Having ruled out this class of circuits, we were
        left to choose from circuits that form a general-purpose computing machine, such as
        arithmetic units, memory blocks, control units and so forth.

        Finally, we wanted to choose among circuits that already had a well-defined,
        \emph{behavioural} description, to avoid using any of the analyzed EDSLs as ``basis'' of
        comparison.

        Taking these considerations into account, we chose to implement, in each of the EDSLs
        analyzed, three circuits originating from the book ``The Elements of Computing
        Systems''\cite{nand2tetris-book}. This book aims to give the reader a deep understanding of
        how computer systems work by taking a hands-on approach, in which the reader is given the
        most basic logic gates and builds, step-by-step, all the hardware and software components
        necessary to implement a complete computer system.

        From the hardware design part of the book, we took our three circuits to be modeled:
        \begin{itemize}
            \item A simple Arithmetic Logic Unit (ALU), from here onwards referred to
                as ``circuit 1''.
            \item A RAM memory block with 64 words, from here onwards referred to as ``circuit 2''.
            \item A CPU with an extremely reduced instruction set (capable of executing the
                \emph{Hack} assembly language defined in the book) from here onwards referred to as
                ``circuit 3''.
        \end{itemize}

        \subsection{Circuit 1: ALU}
        \label{subsec:circuit-alu}
            The Arithmetic Logic Unit built by us is a 2-input ALU, in which each of the inputs (as
            well as the output) is a 16-bit long word (interpreted as two's-complement signed
            integer). It is capable of computing several functions, and the choice of which
            function to compute is made by setting the ALU's 6 \emph{control bits}. To become more
            familiar with this circuit, let's first take a look at its block diagram, shown in
            figure \ref{fig:alu-block}
            \begin{figure}[h]
                \begin{center}
                    \includegraphics[width=0.6\textwidth]{imgs/alu-block.pdf}
                \end{center}
                \caption{Block diagram of circuit 1, showing its input and output ports.
                    \label{fig:alu-block}}
            \end{figure}

            Each of the 6 control bits to the ALU has, in isolation, a well-defined effect on the
            inputs or outputs to the ALU core. The bits \texttt{(zx, nx, zy, ny)} control
            ``pre-processing'' steps for the inputs \texttt{x} and \texttt{y}, with the following
            behaviour:
            \begin{description}
                \item[zx and zy] \emph{Zeroes} the x input (respectively y). The ALU core will
                    receive \texttt{0} as input.
                \item[nx and ny] Performs \emph{bitwise negation} of input x (respectively y).
            \end{description}

            Therefore, the ALU ``core'' itself (adder, and gate) has, as inputs, the results of
            performing these pre-processing steps controlled by \texttt{(zx, nx, zy, ny)}.
            Furthermore, the \emph{output} of the ALU core can also be \emph{bitwise negated} as a
            ``post-processing'' step, controlled by bit \texttt{no}.

            Finally, the control bit $f$ can be used to select which operation is to be performed by
            the ALU core: if we wish to add the two inputs, we need to set $f = 1$, and if we want
            bitwise conjunction, then we need to set $f = 0$.

            Besides the main (16-bit wide) output of the ALU, there are two other output
            \emph{flags}, that indicate predicates over the main output:
            \begin{description}
                \item[zr] Is high whenever $out = 0$.
                \item[ng] Is high whenever $out < 0$.
            \end{description}

            When the ALU is used in the context of a microprocessor these flags can be used, for
            example, to facilitate conditional jumps.

            Even though there are $2^{6} = 64$ possible combinations for the values of the control
            bits, only 18 of these combinations result in interesting functions -- that is because
            several combinations of control bits can be used to calculate the same function. We show
            these 18 functions that the ALU can calculate on table \ref{tab:alu-functions}.
            \input{tables/alu-functions}

            %% TODO: Talk about the construction of the ALU in terms of its parts.


        \subsection{Circuit 2: RAM64}
        \label{subsec:ram-circuit}
            Circuit 2 is a block of RAM with 64 lines, in which each line is a 16-bit word.
            Actually, using the term ``RAM'' to refer to this component is an abuse of terminology,
            as this circuit is nothing more than a register bank.

            All the input and output ports of the circuit are pictured in its block diagram, shown
            in figure \ref{fig:ram-block}.
            \begin{figure}[h]
                \begin{center}
                    \includegraphics[width=0.4\textwidth]{imgs/ram-block.pdf}
                \end{center}
                \caption{Block diagram of circuit 2, a RAM of 64 lines
                    \label{fig:ram-block}}
            \end{figure}

            The circuit has one 16-bit output, named \texttt{out}, and three inputs (\texttt{in},
            \texttt{address} and \texttt{load}). The \texttt{in} port is 16-bit wide and holds a
            value to be written into the RAM. The \texttt{address} port has a width of $\log_{2} 64
            = 6$ bits and holds the address in which reading or writing is to be performed. Finally,
            the \texttt{load} bit controls whether the value currently at \texttt{in} should be
            written to the selected address. There is also one \emph{implicit} input for a clock
            signal in this component.  Implicit, in this case, means that the clock signal is not
            present in any of the models that we developed for this circuit, but must be present in
            any physical implementation.

            The temporal behaviour of this memory block is as follows: At any point in time, the
            output \texttt{out} holds the value stored at the memory location specified by
            \texttt{address}.  If the \texttt{load} bit is high, then the value at \texttt{in} is
            loaded into the memory word specificied by \texttt{address}. The loaded value will then
            be emitted on the output at the \textbf{next} clock cycle.

        \subsection{Circuit 3: The Hack CPU}
        \label{subsec:hack-cpu-circuit}
            Circuit 3, the largest and most complex circuit among the ones we have chosen to
            implement, is the Central Processing Unit for the \emph{Hack} computer, the machine
            described in the book ``The Elements of Computing Systems''\cite{nand2tetris-book}.

            The Hack computer is based on the \emph{Harvard architecture}, that means that it has
            different storage components and signal pathways for instructions and data. Therefore,
            the Hack CPU expects to be connected to \emph{two} memory blocks, the instruction memory
            and the data memory. Having this in mind facilitates the understanding of the CPU's
            block diagram, shown in figure \ref{fig:cpu-block}
            \begin{figure}[h]
                \begin{center}
                    \includegraphics[width=0.9\textwidth]{imgs/cpu-block.pdf}
                \end{center}
                \caption{Block diagram of circuit 3, the Hack CPU
                    \label{fig:cpu-block}}
            \end{figure}

            The Hack architecture has an \emph{extremely} reduced instruction set, and consists in
            fact of only two instructions (each 16-bit wide): A (meaning ``address'') and
            C (meaning ''compute''). The A instruction can be used as a means to load numerical
            literals into the data memory, as well as setting a special ``cache'' register inside
            the CPU. The C instruction is the one responsible for effectively performing
            computations using the ALU, testing outputs and jumping. More details about programming
            in the Hack assembly language can be found in \cite{nand2tetris-chapter-assembly}.

            The meaning of each of the CPU's input and output ports becomes much clearer when we
            look at the context in which the CPU is inserted, namely, the memory modules to which it
            is connected. So, let's analyze the CPU's ports by taking a look at figure
            \ref{fig:cpu-memory}.
            \begin{figure}[h]
                \begin{center}
                    \includegraphics[width=1.0\textwidth]{imgs/cpu-memory.pdf}
                \end{center}
                \caption{The Hack CPU connected to the data and instruction memory blocks
                    \label{fig:cpu-memory}}
            \end{figure}

    \section{Analysis of the EDSLs}
    \label{sec:edsls}

        \subsection{Lava}
        \label{subsec:lava}
            Lava\cite{lava1998} is an EDSL for hardware description developed originally around 1998
            at Chalmers University of Technology, in Sweden. It uses Haskell as the host language,
            and circuits described in Lava are \emph{deeply embedded}.

            The Lava EDSL has several ``dialects'', among which are Xilinx-Lava, York-Lava,
            Kansas-Lava and Chalmers-Lava. Xilinx-Lava\cite{xilinx-lava} was developed by Satnam
            Singh and puts a greater emphasis on the \emph{layout} of the described circuits,
            focusing on their implementation in Xilinx's FPGAs. York-Lava was developed as part of
            the Reduceron\cite{reduceron} project, and is a variation of Chalmers-Lava, omitting
            some features and adding some others, like a ``Prelude'' of commonly used circuits
            ((de)multiplexers, (de)coders, RAM memory blocks, etc.). Chalmers-Lava is considered the
            ``standard'' dialect, also being the one which was first developed, therefore it was
            chosen as the one to be studied in this project.

            Before diving into the inner workings of the Chalmers Lava library, we first need to
            make clear that there are two very distinct versions of this library. The original paper
            that defines the Lava language\cite{lava1998} contains the first version, while the
            current version is the one defined in a later paper\cite{observable-sharing-1999} by
            Koen Claessen and David Sands. This current version of Chalmers Lava is the one in which
            our case study is implemented.

            As already said, Lava uses a \emph{deep embedding}, and the datatype used to represent a
            circuit is \texttt{Signal}, defined in figure \ref{fig:lava-signal}. As can be noticed
            from the definition, the \emph{actual} circuit type (\texttt{S}) is ``wrapped'' around
            the \texttt{Ref} type constructor. This has to do with the approach that Lava takes to
            solving the problem of observable sharing, which is to rely on comparing
            \emph{references to object} given by the Haskell implementation, to detect cycles in
            syntax graphs representing circuits. This approach is the cause of some of Lava's
            advantages as well as disadvantages, which will be discussed further ahead.

            \begin{figure}[h]
                \begin{center}
                    \input{code/lava-signal.tex}
                \end{center}
                \caption{Lava's \texttt{Signal} datatype, used to represent circuits.
                    \label{fig:lava-signal}}
            \end{figure}

            Having defined a circuit operating on values of a type \texttt{a} to have type
            \texttt{Signal a}, then there are several circuit combinators provided by Lava, which
            take circuits as inputs and provide circuits as outputs. For example, on figure
            \ref{fig:lava-boolean-combinators} we show some boolean circuit combinators:

            \begin{figure}[h]
                \begin{center}
                    \input{code/lava-boolean-combinators.tex}
                \end{center}
                \caption{Some of Lava's boolean circuit combinators.
                    \label{fig:lava-boolean-combinators}}
            \end{figure}

            With Lava, one can also model circuits operating on \texttt{Int}s (and there are several
            interesting integer circuit combinators already included in the Lava library). However,
            our goal in this project was to model \emph{boolean} circuits and, besides that, integer
            circuits offer a reduced set of features.


            \subsubsection{Circuits modeled}
            \label{subsubsec:lava-circuits}
                TODO: expose and discuss the circuits modeled in Lava, in light of the aspects being
                analyzed.

                In order to be able to describe circuit 1, the ALU (described in more detail on
                section \ref{subsec:circuit-alu}), we first needed to model the necessary
                parts. The ``core'' of the ALU is composed of a 16-bit ripple-carry adder and
                a 16-bit \texttt{AND} gate. To model the ripple-carry adder we used full adders as
                parts, which in turn used half adders. To get used to the wat in which
                circuits are described in Lava, let us first take a look at the definition of the
                hierarchy of adders:
                \input{code/lava-circuit1-model-adders.tex}

                Based on this small model we can already make some observations concerning the
                aspects that we are analyzing. These observations are:
                \begin{itemize}
                    \item All circuits in Lava must be modeled as \emph{uncurried} functions, that
                        is, if multiple inputs are needed, they need to be packed into one tuple, the
                        same ``packing'' happens also in the case of multiple outputs.

                    \item The \emph{basic} type of input/output for all circuits modeled is
                        \texttt{Signal Bool}. This is not coincidental: Lava's VHDL generation
                        backend can only work with circuits whose input/output types are
                        \texttt{Signal Bool} or any nested combination of tuples and lists thereof.
                        This limitation makes Lava have low \textbf{extensibility}, not allowing
                        -- for example -- user-defined types.

                    \item In Lava, (families of) circuits with variable-sized inputs/outputs are
                        modeled as lists (as can be seen in the definition of
                        \texttt{rippleCarryAdder}). This approach has a good \textbf{genericity},
                        but is \textbf{not type-safe enough}. For example, we could have a circuit
                        assuming that its inputs are 32-bit wide.  There is no way to enforce, at
                        \emph{Haskell compilation time}, that inputs with correct size are
                        provided.  Possible problems could only be detected at simulation or VHDL
                        generation.
                \end{itemize}

                Now, after having defined all the necessary parts, lets take a look at the
                ALU circuit itself:
                \input{code/lava-circuit1-model-alu.tex}

                In the definition of the ALU itself, we would like to have a user-defined datatype
                to represent the kinds of functions that can be computed by the ALU (functions
                listed on table \ref{tab:alu-functions}). However, due to the limitations of the
                VHDL backend already discussed, we have to define \texttt{ALUControlBits} as simply
                a \emph{type synonym} for a 6-tuple of bits.

                Besides modelling the three circuits in Lava, we also simulated them. The definition
                of the ALU circuit in the book "The Elements of Computing
                Systems"\cite{nand2tetris-book} has a pretty extensive truth table to test the
                circuit model, which was used to simulate the ALU. However, let's take a look at a
                simpler simulation case, that of a half-adder:
                \input{code/lava-circuit1-simulation-hadd.tex}

                Simulation of combinational circuits is performed by the Lava function
                \texttt{simulate}; it takes as arguments the circuit to simulate and an input
                combination. In the example of simulation for the \texttt{halfAdder}, we \emph{map}
                the simulation over a list of input combinations, covering all possible cases.

                The attentive reader might be asking why is this simulation not an automated test,
                i.e, why are we \textbf{not} comparing the results of the simulation with an
                \emph{expected} output sequence. This has to do with the way in which Lava handles
                the problem of observable sharing: values of type \texttt{Signal a} encapsulate
                effectively a \emph{runtime reference} to an object of type \texttt{a}. Therefore,
                even though \emph{actual} and \emph{expected} outputs might appear to be equal, they
                are considered different by Lava. Here is the offending \texttt{Eq} instance from
                the Lava library (module \texttt{Lava.Signal}):
                \begin{haskellcode}
    instance Eq (Signal a) where
        Signal (Symbol r1) == Signal (Symbol r2) = r1 == r2
                \end{haskellcode}

                With the drawback of not having \emph{automated} testing, we can say that Lava does
                provide good \textbf{simulation} capabilities, with an interface that is easy to
                understand for functional programmers.

                Now, before moving on to the next circuit
                studied, let's take a look at how Lava handles \emph{formal verification} with two
                examples: checking that a full adder is commutative and that the output of an
                incrementer circuit is always different from its input:
                \input{code/lava-circuit1-verify-fulladder.tex}

                A property over a circuit in Lava is modeled as a circuit containing \emph{one
                    boolean output}, which -- for the property to be true -- needs to be \emph{true}
                for any combination of inputs (these properties are called \emph{safety
                    properties}). Lava performs the verification by converting the circuit model to
                a CNF logical formula and executing an external SAT solver on the negation of the
                formula: the property being verified is \emph{valid} if and only if the negated
                formula is unsatisfiable. The verification for the incrementer introduces another
                detail of this kind of verification:
                \input{code/lava-circuit1-verify-incrementer.tex}

                We can see by the type of the verification function that it is a \emph{property
                    generator}, i.e, for each integer \texttt{n}, it gives a property. An
                incrementer is a circuit with generic input/output size, but the SAT-solving
                approach to verification can only prove properties for \emph{circuits of fixed
                    size}. Therefore, we can only verify a finite number of particular instances of
                the circuit.

                Moving on to circuit 2 (the RAM block), we will take a look at how Lava handles
                sequential circuits. The ``fundamental''\footnote{here, \emph{fundamental} means
                    that all sequential circuits have -- directly or indirectly -- \texttt{delay} as
                    one of its building blocks} sequential circuit in Lava is \texttt{delay}.  It
                takes two boolean signals as input and outputs a single boolean signal. Its
                semantics is that the output signal will correspond tho the input signal
                \emph{delayed} by one clock cycle, with the other parameter being the first value of
                the output.  Using this fundamental circuit, we modeled the first building block of
                our hierarchy of memory elements: a 1-bit register with input and load signals:
                \input{code/lava-circuit2-model-reg.tex}

                In this model, we use a \texttt{mux} to control whether the next state of the output
                will be simply the previous state, or the input value will be ``loaded'' into the
                register. Now, a 1-bit register can easily be ``lifted'' into a generic n-bit
                circuit:
                \input{code/lava-circuit2-model-regN.tex}

                The \texttt{regN} definition is \emph{generic}, and parameterized by the size of the
                input and output (\texttt{n}). This means that \emph{for each value of n, there is a
                    circuit \texttt{regN n}}. In Lava, however, we can only simulate and generate
                VHDL for specific instances of this family of circuits. The restriction with regards
                to VHDL generation is not conceptual, that because VHDL has good support for
                \emph{generic components}, and one could imagine Lava generating generic VHDL from
                generic circuit models. But, leaving that discussion aside, let's take a look at the
                simulation case for \texttt{regN}:
                \input{code/lava-circuit2-simulation-regN.tex}

                The \texttt{simulateSeq} function, which we already used to test the ALU (a
                combinational circuit), is actually intended for the simulation of sequential
                circuits: the list of inputs its given is the sequence of values present at the
                input ports of the circuit under test -- one element of the list for each clock
                cycle. The list of outputs given by \texttt{simulateSeq} has a similar
                interpretation.

                Having the core sequential component for our memory bank (\texttt{regN}), we modeled
                some other helper components (such as an \emph{address decoder} and a 64-to-1
                \emph{multiplexer}). With all the components at our disposal, we then modeled the
                RAM block itself:
                \input{code/lava-circuit2-model-ram64.tex}

                All the registers in the memory bank are connected to the ``global'' input word for
                the bank, but the load signal for any particular register is active \emph{iff} the
                global \texttt{load} signal is active \emph{and} (\texttt{<\&>}) that particular
                memory line is selected. Finally, to be precise, \texttt{ram64Rows} actually defines
                a family of circuits, one for each value of \texttt{n}. The one we are interested in
                is \texttt{ram64Rows 16}, for a RAM block with 64 lines, in which each line is 16
                bits wide.

                Finally, the last circuit we studied under Lava (circuit 3) is the Hack CPU
                (described in more detail on section \ref{subsec:hack-cpu-circuit}). The CPU circuit
                is mostly combinational, as it contains \emph{no form of pipelining} and
                exactly one instruction is executed per clock cycle. However, there is one
                sequential component of the CPU: the \emph{program counter}:
                \input{code/lava-circuit3-model-pc.tex}

                The program counter counts cyclically between $ 0 $ and $ 2^{n-1} $, and can have
                its value reset or set to a particular value at any moment. Having defined the
                program counter, there are still some helper parts to define before writing
                the model for the CPU itself: most importantly, we need an \emph{instruction
                    decoder}, responsible for interpreting each \texttt{Hack} instruction and
                outputting several \emph{control bits} that are used to direct the data flow inside
                the CPU during each instruction execution cycle:
                \input{code/lava-circuit3-model-instruction-decoder.tex}

                Here we notice again some limitations of Lava with regards to datatypes: We are
                limited to lists and tuples of \texttt{Signal Bool} (to keep the circuit
                synthesizable). Here we decided to model the \emph{Hack} instruction itself and
                the control flags as tuples, to prevent size-related runtime errors. However, using
                tuples made the model more ``cluttered'', as tuples are \emph{not} data structures
                prone to slicing and regrouping.

                Using \emph{fixed-length vectors}, perhaps based on the recent ``Type-level
                Naturals'' GHC
                \footnote{The Glorious Glasgow Haskell Compilation System:
                    \url{http://www.haskell.org/ghc}}
                extension \cite{website:ghc-typenats}
                (introduced in GHC 7.6 and being improved for GHC 7.8) would make modelling in Lava
                \emph{safer} and more comfortable.


        \subsection{ForSyDe}
        \label{subsec:forsyde}
            The Haskell ForSyDe library is an implementation of the ``Formal System Design''
            approach to hardware modelling\cite{forsyde1999}. The ForSyDe approach per se has
            several significant differences when compared to Lava, and even when the two EDSLs agree
            on \emph{what to do}, sometimes they differ on how to achieve those goals.

            To better understand what characterizes the ForSyDe methodology, we first have to
            establish some vocabulary:
            \begin{description}
                \item[System] In ForSyDe, a system or circuit is a network of processes
                    interconnected by \emph{signals}.

                \item[Signal] A signal is, intuitively, a stream of information that flows between
                    processes. It carries events of some type, and each event has an associated
                    \emph{tag}. The meaning of the tag is defined by the \emph{model of
                        computation} used.

                \item[Process] A process is nothing more than a pure function on signals. A process
                    \emph{is able} to hold internal state. But, given the same input (possibly
                    infinite) signals, it produces the same output signals.

                \item[Process constructor] Every ciruit in ForSyDe (even simplest combinational ones)
                    is built using a \emph{process constructor}. A process constructor can be seen as
                    a skeleton of behaviour, and it clearly separates computation from
                    synchronization aspects. A process constructor takes a combinational function
                    (called \emph{process function}) as parameter -- expressing the computation
                    aspect of the process, and possibly some extra values. There are combinational
                    and sequential process constructors, and some representative examples from each
                    class will be described in more detail in a specific subsection
                    (\ref{subsubsec:forsyde-synchprocs}).
            \end{description}

            \subsubsection{Models of Computation}
            \label{subsubsec:forsyde-mocs}
                The definition of signal given above is purposefully ``vague'' mainly because the
                precise definition of signals depends on the \emph{model of computation} being
                used. ForSyDe has (currently) process constructors for the following models of
                computation:
                \begin{description}
                    \item[Synchronous] All processes in this MoC have a global, implicit
                        \texttt{clock} input, and the tags in the signals are increasing natural
                        numbers. Therefore, a signal can be viewed as a \emph{stream} of values, one
                        for each clock cycle. At each clock cycle, \emph{all} processes consume
                        exactly one value from each of its inputs and produce one value at each of
                        its outputs.

                    \item[Untimed] In the untimed MoC, the processes fire individually and there is
                        no notion of global clock. A process only evaluates when its inputs have a
                        minimum number of values \emph{ready} to be read. The number of needed
                        values can vary per input, but is constant throughout execution.

                    \item[Continuous] The Continuous MoC interprets signals as continuous,
                        one-variable piecewise functions of time. It can be used to model some forms
                        of analog circuits, for example.
                \end{description}

                Among all MoCs, perhaps the most ``notable'' one is the Synchronous MoC, because it
                reflects the usual interpretation of signals as wires and the vast majority of
                digital designs nowadays having a global clock. Also, all of our studied circuits
                were modelled in ForSyDe using the Synchronous MoC. Therefore, it is interesting to
                take a deeper look at it.

                First, lets take a look at the behaviour of a system which has an one integer input
                port and one integer output, and in which the value of the output is equal to the
                input plus 4. The interface and internal architecture of this system
                (\emph{addFour}) is depicted in figure \ref{fig:forsyde-addFour}.
                \begin{figure}[h]
                    \begin{center}
                        \includegraphics[width=1.0\textwidth]{imgs/forsyde-addFour.pdf}
                    \end{center}
                    \caption{The addFour circuit, example of usage of the Synchronous MoC
                        \label{fig:forsyde-addFour}}
                \end{figure}

                In this system, each of the constituent processes is built using the \texttt{mapSY}
                process constructor, a constructor of the synchronous model of computation (its name
                ends in ``SY''). It takes a combinational function (in this case ``+1'') and
                evaluates it for each event in the input signal, generating a corresponding event in
                the output signal.

                Another characteristic of ForSyDe which makes the synchronous MoC even more
                significant is that only systems that are modeled \textbf{exclusively} with process
                constructors of the synchronous model can be translated into VHDL by ForSyDe.

                ForSyDe is a \emph{deeply embedded} EDSL, but it takes a significantly different
                approach than the one taken by Lava: instead of having some set of ``atomic''
                circuits (they correspond to the constructors of the \texttt{S} type in Lava),
                ForSyDe uses Template Haskell to \emph{reify} Haskell source code into a syntax
                tree, and use this syntax tree in order to simulate and/or translate the circuit
                model into VHDL.

                This approach has some advantages and disadvantages, which we will look into with
                more details on section \ref{subsubsec:forsyde-circuits}. For now, let's first take
                a look at how to build processes in ForSyDe using the \emph{synchronous process
                    constructors}.

            \subsubsection{Synchronous Process Constructors}
            \label{subsubsec:forsyde-synchprocs}
                TODO: Example of usage of \texttt{mapSY}, with a simple \texttt{ProcFun}. Mention
                that limitations to ProcFun will be discussed as the case study circuits are
                analyzed.

                TODO: Example of usage of a state-machine or scanl constructor, mentioning the
                approach taken by ForSyDe, in which conceptually ALL processes are sequential in
                nature (have clock input), but some have the property that the current state does
                NOT depend on previous states.


            \subsubsection{Circuits modeled}
            \label{subsubsec:forsyde-circuits}
                TODO: expose and discuss the circuits we modeled as case study, highlighting the
                advantages and disadvantages of ForSyDe found while modelling them.

                Advantages: more modular VHDL generated (hierarchical). Higher-level descriptions.

                Disadvantages: name handling, not actively maintained

                When modelling the circuits we decided to study under ForSyDe, we considered 2 kinds
                of models:
                \begin{description}
                    \item[High-level] A model that uses Haskell constructs inside the process
                        functions (\texttt{ProcFun}) as close as possible to what
                        a functional programmer would normally use. These models do not comply with
                        ForSyDe's constraints on the syntax tree of process functions for
                        synthetization, and therefore \textbf{can not be translated to VHDL}.

                    \item[Synthesizable] These models are more fine-grained, and use
                        \textbf{exclusively} constructs that allow them to be synthesized by
                        ForSyDe's VHDL backend. They ``look'' much less like functional programs and
                        more like traditional pen-and-paper diagrams of circuits.
                \end{description}

                Let's start our analysis by looking at the \emph{high-level} model for circuit 1,
                the ALU:
                \input{code/forsyde-circuit1-model-alusim.tex}

                The first thing to notice is that the system is working over \emph{16-bit integers},
                as by the definition of \texttt{WordType}. This is not exclusive of the high-level
                model, however, as ForSyDe can also produce VHDL models working with integers.

                TODO: explain the \texttt{ProcFun} type and how the newProcFun TH splice and the
                ``d'' quasi-quoters work.

                Now let's compare the high-level model of the ALU with the \emph{synthesizable} one,
                and discuss along the way how the limitations of ForSyDe's VHDL generation backend
                constrained our design:
                \input{code/forsyde-circuit1-model-alusyn.tex}

                TODO: Discuss how we can't use user-defined datatypes, and the restrictions on the
                Haskell syntax that can be used as input for a \texttt{newProcFun} splice (single
                clauses, no pattern matching, import restrictions, etc).

                By analyzing the second studied circuit (the RAM block), we will gain some insight
                into other significant characteristic of the ForSyDe library -- the usage of
                fixed-length vectors, and the \emph{manual} management of process names:

                TODO: discuss how -- on the one hand -- ForSyDe's FSVec's can help make modelling
                more type safe but on the other hand the current implementation is very ``hackish''
                and could ALSO make some use of recent developments in GHC.

                TODO: discuss how ForSyDe's concepts of processes and (sub)components is responsible
                for really elegant and modular generated VHDL code but, on the other hand, forces
                the user to manage naming of the processes manually. Give some possible suggestions
                for this problem.

        \subsection{Coquet}
        \label{subsec:coquet}
            The third analyzed EDSL for hardware description, Coquet\cite{coquet2011},
            is strikingly different from both others. Most of these differences can be explained in
            one way or another by its choice of host ``language'' -- Coq\footnote{``Coq'' is not
                the name of a language, but a theorem-proving system that uses different languages
                for defining terms, interactive commands, and user-defined tactics}.

            Coq is an interactive theorem prover based on \emph{intuitionistic type theory}. In the
            context of Coq, the concepts of ``term'' and ``type'' are far more intertwined than,
            say, in Haskell. Types in Coq can contain references to terms and vice-versa. A very
            typical example of these so-called \emph{dependent types} is the type(-family) of
            vectors with a certain length:
            \begin{verbatim}
    Inductive vec A : nat -> Type :=
        | nil  : vec A 0
        | cons : forall (h : A) (n : nat),  vec A n -> vec A (S n).
            \end{verbatim}

            By having the length of the vector being part of the type, we can \emph{enforce} several
            useful properties of functions operating on vectors. In fact, the type-system of Coq is
            so expressive that it can encode any proposition of \emph{intuitionistic propositional
                logic}.

            Given such expressive power, one can imagine that it might be useful to express circuits
            in Coq, and use it to prove interesting properties about these circuits. This is exactly
            the goal of Coquet. How this goal is achieved and the modelling of our studied circuits
            in Coquet is discussed in the following subsections.

            \subsubsection{Modelling circuits}
            \label{subsubsec:coquet-modelling}
                Coquet is a deep-embedded DSL, thus it represents circuits as a datatype. By using
                dependent types, a designer modelling a circuit in Coquet is able to prevent certain
                kinds of ``errors'' much earlier in the design process, because the
                \emph{well-formedness} is guaranteed by construction, i.e, every circuit built using
                the constructors provided by Coquet are well-formed by definition. Let's take a look
                at the \emph{Circuit} data type declaration:
                \begin{figure}[h]
                    \begin{center}
                        \begin{verbatim}
    Context {tech : Techno}
    Inductive ℂ : Type -> Type -> Type :=
    | Atom : ∀ {n m : Type} {Hfn : Fin n} {Hfm : Fin m}, techno n m -> ℂ n m
    | Plug : ∀ {n m : Type} {Hfn : Fin n} {Hfm : Fin m} (f : m -> n), ℂ n m
    | Ser : ∀ {n m p : Type}, ℂ n m -> ℂ m p -> ℂ n p
    | Par : ∀ {n m p q : Type}, ℂ n p -> ℂ m q -> ℂ (n + m) (p + q)
    | Loop : ∀ {n m p : Type}, ℂ (n + p) (n + p) -> ℂ n m
                        \end{verbatim}
                    \end{center}
                    \caption{The Circuit (ℂ) datatype in Coquet
                        \label{fig:coquet-circuit-type}}
                \end{figure}

                The \texttt{ℂ} type is parameterized by two types. These types are the \emph{input} and
                \emph{output} types of the circuit, respectively. They \textbf{do not} represent
                what is ``carried'' on the wires, but the \emph{structure} of the circuit's input
                and output ports: How many of them there are, how are they grouped and how are they
                named.

                There are 2 \emph{atomic} constructors from which an element of \texttt{ℂ} can be
                built and 3 \emph{combinators}, which build a circuit based on other circuit(s). By
                observing the serial and parallel composition combinators (\texttt{Ser} and
                \texttt{Par}, respectively), we notice that the input and output types match exactly
                as expected.

                The 2 atomic constructors constrain the types \texttt{n} and \texttt{m} by requiring
                them to have instances of the ``Fin'' type class, i.e, they have to be \emph{finite}
                types (types from which a finite list of unique elements can be obtained). This
                constraint is important given the interpretation that these types (\texttt{n} and
                \texttt{m}) have: each element of \texttt{n} (respectively \texttt{m}) stands for an
                input (respectively output) ``wire'' in the circuit interface.

                The case of the ``Atom'' constructor is particularly revealing of how Coquet works:
                this constructor is parameterized by an \emph{instance} of the type class
                \texttt{Techno} for the types \texttt{n} and \texttt{m}. What this instance provides
                (in the code fragment that reads ``\texttt{techno n m}'') is the \emph{type of the
                    fundamental gate} in the technology being used. We could choose our modeled
                circuits to have, for example, NAND, NOR, or other (more exotic) gates as
                fundamental.

                As an ``usage example'' of Coquet, we show two simple circuits (\texttt{NOT} and
                \texttt{HALFADD}), along with proofs that they implement the expected functions over
                booleans. Let's start with \texttt{NOT}:
                \begin{verbatim}
    Definition NOT x nx : ℂ [:x] [:nx]  :=  Fork2 _ |> (NOR x x nx).

    Instance NOT_Implement {x nx} : Implement (NOT x nx) _ _ negb.
    Proof.
        intros ins outs H.
        unfold NOT in H.
        tac.
    Qed.
                \end{verbatim}

                The input type of \texttt{NOT} is a \emph{tagged unit} with tag \texttt{x},
                similarly, the output type has tag \texttt{nx}. There is some \emph{notation}
                introduced by Coquet to make the creation of tagged units more convenient. The
                \texttt{NOT} circuit is a serial composition (denoted as \texttt{|>} of a
                \texttt{Fork2} circuit (which simply splits the input into two identical copies) and
                a \texttt{NOR} circuit, which is the underlying fundamental gate in this case.

                Below the definition of the circuit itself we state and prove the fact that our
                circuit implements the desired function (boolean negation, \texttt{negb}). More
                details on exactly what is meant by ``implements'', as well as the workings of plugs
                and tags, are exposed further ahead. Now let's take a look at a half-adder
                described in Coquet:
                \begin{verbatim}
    Definition HADD a b s c : ℂ ([:a] + [:b]) ([:s] + [:c]) :=
        Fork2 ([:a] + [:b]) |> (XOR a b s & AND a b c).

    Instance HADD_Implement {a b s c} :
        Implement (HADD a b s c) _ _
        (fun (x : bool * bool) => match x with (a,b) => (xorb a b, andb a b) end).
        Proof.
            unfold HADD;  intros ins outs H;  tac.
        Qed.
                \end{verbatim}

                First of, the sum types that are given as parameters to \texttt{ℂ} indicate that we
                have two input ports and two output ports. By using \texttt{Fork2} on a binary sum
                (\texttt{[:a] + [:b]}), we create as output a sum type in which each of the
                components is in itself a sum: that matches exactly the interface of the component
                after the \texttt{|>} operator. On the right side of the serial composition, we have
                a parallel composition of \texttt{XOR} and \texttt{AND}, giving two outputs:
                respectively the sum (\texttt{[:s]}) and carry-out (\texttt{[:c]}) 

                Together with the definition, we prove that the \texttt{HADD} circuit implements the
                boolean function we would expect, and the proof is similar to the case of
                \texttt{NOT}. It makes use of a Coquet custom tactic (\texttt{tac}), but a more
                throughout example of proof of functional correctness will be given futher ahead.
                Also, in the case of the adder used in our case study (ripple-carry adder), we prove
                that the circuit implements the \emph{actual} addition function on binary integers,
                and not some boolean equivalent.

                As a last detail on the ``user interface'' of Coquet, there is the definition of
                what exactly are the input and output types (a circuit of type \texttt{ℂ n m} has
                input type \texttt{n} and output type \texttt{m}). Usually, in the Coquet
                paper\cite{coquet2011} and in the examples provided with the library, input and
                output types are \emph{sum types} in which the terms of the sum are \emph{tagged
                    units}. Using tags serves a form of ``documentation'', giving someone reading
                the circuit model an idea of what role does each input/output port play. The
                \emph{type family} of tagged unit types is defined as follows:
                \begin{verbatim}
    Inductive tag (t : string) : Type := _tag : tag t

    Notation "[: x ]" := (tag x).
    Notation "[! x ]" := (_tag x).
    Notation "[!!]"   := (_tag _).
                \end{verbatim}

                For each string \texttt{t}, there is a type \texttt{tag t}, and this type has
                exactly one inhabitant. There are also, as part of Coquet, some definitions to make
                working with sum types less tiresome. For example, there is the function
                \texttt{sumn} which, given a type \texttt{t} and a natural \texttt{n}, returns a
                sum type with \texttt{n} elements and in which each element has type \texttt{t}.
                This might be useful if we are defining a n-bit adder:
                \begin{verbatim}
    Definition RIPPLE cin a b cout s n :
        ℂ  ([:cin] + sumn [:a] n + sumn [:b] n)  (sumn [:s] n + [:cout]) := ...
                \end{verbatim}

                While the provided examples use sums of tagged units as the input/output types, they
                can be more general: as seen in the definition of the circuit type (Fig.
                \ref{fig:coquet-circuit-type}), the only requirement is that they belong to the
                \texttt{Fin} type class, which is defined as follows:

                \begin{verbatim}
    Class Fin A := {
        eq_fin : eqT A;
        enum   : list A;
        axiom  : forall (x : A), count (equal x) enum = 1
    }.
                \end{verbatim}


            \subsubsection{Circuit semantics in Coquet}
            \label{subsubsec:coquet-semantics}
                TODO: Explain what the meaning relation for a circuit in Coquet is, give the
                (inductive) definition of the meaning relation and comment on it.

                TODO: Explain how the meaning relation is too ``low-level'', and how Coquet uses
                \emph{data abstraction} and \emph{function abstraction} to prove the correctness of
                circuits. The proofs of correctness are proofs that a circuit either
                \textbf{Realizes a high-level relation} or \textbf{Implements a high-level function}
                over the high-level input/output types.

                We give the definitions of \texttt{Realizes} and \texttt{Implements}, as well as
                walk over a small example of functional correctness proof.

            \subsubsection{Circuits modeled}
            \label{subsubsec:coquet-circuits}
                TODO: Expose the studied circuits modeled in Coquet, highlighting advantages and
                disadvantages of the Coquet approach along the way.

                TODO: circuit 1 (ALU) -- Model, proof of some of its components.

                TODO: circuit 2 (RAM) -- Model.

            \subsubsection{Possible improvements and future work}
            \label{subsubsec:coquet-improv}
                The approach to circuit modelling is \emph{very} generic, and leaves room for
                extension in several aspects, even though the library is already provided with some
                reasnoable deafults.

                For example, the definition of the \emph{meaning relation} for circuits (by
                induction on circuit structure) is parameterized by the \emph{type \texttt{T} of was
                    is carried in the wires}. Even though the library already provides examples for
                booleans and streams of booleans, it could also be interesting to add cases for
                dealing with some three-valued logics, or a case for IEEE1164's std\_logic type,
                used often in VHDL.

                Another interesting point is that Coquet defines a \texttt{stream} type family, and
                then proceeds to define several interesting function over \texttt{stream}, as well
                as an instance for the meaning relation. The type family is defined as follows:
                \begin{verbatim}
    Definition stream A := nat -> A.
                \end{verbatim}
                If instead of using \texttt{nat} in the above definition, we generalized it a bit
                more (abstracting a new type parameter), we arrive at the concept of an ``event
                stream'':
                \begin{verbatim}
    Definition events tag A : tag -> A.
                \end{verbatim}
                This is exactly how ForSyDe defines its ``signals'', so we could model circuits in
                models of computation other than the synchronous model (which is the one allowed by
                the current \texttt{stream} definition).



    \section{Conclusions}
    \label{sec:conclusions}
        TODO: Reiterate the analysis of the EDSLs spread throughout the analysis of each of the
        studied circuits, but in a more summarized manner, actually \textbf{comparing} the EDSLs
        among themselves, \textbf{by aspect} (the ones we defined in section \ref{subsec:aspects}).


    \bibliographystyle{plain}
    \bibliography{references}

\end{document}
